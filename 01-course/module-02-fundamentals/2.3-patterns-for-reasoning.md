# Section 2.3: Patterns for Reasoning - Prompt Templates

> **üìã For Circuit Users (No API Access Required)**
>
> This guide extracts the key prompts from `2.3-patterns-for-reasoning.ipynb` into copy-paste templates for use in web-based AI chat interfaces like Cisco's internal Circuit.

| **Aspect** | **Details** |
|-------------|-------------|
| **Goal** | Master few-shot exemplars, chain-of-thought reasoning, and reference citations |
| **Time** | ~25 minutes |
| **Prerequisites** | Complete Sections 2.1-2.2 and understand role prompting + structured inputs |
| **Next Steps** | Continue to Section 2.4: Advanced Workflows |

---

## üéØ Learning Objectives

By the end of this section, you'll be able to:
- ‚úÖ Use few-shot examples to teach AI your coding style and standards
- ‚úÖ Apply chain-of-thought reasoning for systematic debugging and analysis
- ‚úÖ Implement reference citations to ground responses in documentation

---

## üìö Tactic 3: Few-Shot Examples

**Teach AI your preferred styles and standards through carefully crafted examples**

Few-shot prompting is your secret weapon for consistent, accurate outputs. By showing the AI 2-5 examples of exactly what you want, it learns patterns you'd struggle to describe in words.

**What "Styles and Standards" Means:**
- Coding conventions (error handling, naming, documentation)
- Error message patterns (tone, detail level, format)
- Commit message styles (conventional commits, emoji prefixes)
- Test case patterns (given-when-then, arrange-act-assert)
- API response structures (pagination, error codes)

**Few-Shot Terminology:**
- **Zero-shot:** No examples (instructions only)
- **One-shot:** Single example
- **Few-shot:** 2-5 examples (sweet spot for most tasks)
- **N-shot:** Many examples for complex patterns

---

### üìù Example 1: Log Parsing with Consistent Format

**Copy this to Circuit:**

```
SYSTEM CONTEXT: Extract service names and error types from log entries following the examples provided.

EXAMPLE 1:
Input: "[ERROR] payment-service: Database connection pool exhausted"
Output: Service: payment-service, Error: connection_pool

EXAMPLE 2:
Input: "[WARN] user-auth: Rate limit exceeded for API endpoint"
Output: Service: user-auth, Error: rate_limit

EXAMPLE 3:
Input: "[ERROR] notification-hub: Message queue timeout after 30s"
Output: Service: notification-hub, Error: timeout

Now apply this pattern to extract from:
"[ERROR] inventory-manager: Cache invalidation failed during peak load"
```

**‚úÖ Self-Check: Your response should:**
- [ ] Match the exact format: "Service: X, Error: Y"
- [ ] Extract the service name correctly
- [ ] Categorize the error type consistently
- [ ] Use underscores in error types (not spaces)

**üí° Key Insight:** The AI learned the format, naming conventions, and categorization style from just 3 examples!

---

### üìù Example 2: Infrastructure Alert Categorization

**Copy this to Circuit:**

```
Categorize infrastructure alerts following the examples provided.

EXAMPLE 1:
Input: "SSL certificate expires in 7 days for payment gateway"
Output: Category: SECURITY

EXAMPLE 2:
Input: "Load balancer health check failing for 2/8 backend servers"
Output: Category: AVAILABILITY

EXAMPLE 3:
Input: "Backup job completed with 3 file permission warnings"
Output: Category: MAINTENANCE

Now categorize this alert:
"Failed login attempts increased 400% on admin portal"
```

**‚úÖ Self-Check: Your response should:**
- [ ] Use one of the three exact categories (SECURITY, AVAILABILITY, MAINTENANCE)
- [ ] Provide the category label only (matching the format)
- [ ] Choose SECURITY for this authentication-related alert

---

## üéØ Activity 2.1: Try It Yourself - Few-Shot Examples

**Scenario:** You want AI to categorize infrastructure alerts using YOUR team's specific categories, not generic ones.

### Step 1: Without Examples (Inconsistent)

**Copy this to Circuit:**

```
Categorize infrastructure alerts.

Categorize this alert: "Failed login attempts increased 400% on admin portal"
```

**Note the response... it might use categories like "Security Issue" or "Authentication Problem" instead of your team's standard labels!**

---

### Step 2: With Few-Shot Examples (Consistent)

**Now copy this to Circuit (new chat recommended):**

```
Categorize infrastructure alerts following the examples provided.

EXAMPLE 1:
Alert: "SSL certificate expires in 7 days for payment gateway"
Category: SECURITY

EXAMPLE 2:
Alert: "Load balancer health check failing for 2/8 backend servers"
Category: AVAILABILITY

EXAMPLE 3:
Alert: "Backup job completed with 3 file permission warnings"
Category: MAINTENANCE

Now categorize this alert:
"Failed login attempts increased 400% on admin portal"
```

### üìä Self-Evaluation Checklist

Compare both responses. The few-shot version should:
- [ ] Use exactly one of the three categories (SECURITY, AVAILABILITY, MAINTENANCE)
- [ ] Match the format from examples
- [ ] Choose SECURITY (not a variant like "Security Issue")
- [ ] Not invent new categories

**Score yourself:**
- **4/4 checks** = Excellent! Few-shot examples enforced consistency ‚úÖ
- **2-3/4 checks** = Good, but try adding more diverse examples
- **0-1/4 checks** = Make examples more explicit about the allowed categories

---

## ‚õìÔ∏è Tactic 4: Chain-of-Thought Reasoning

**Guide AI through systematic step-by-step problem breakdown**

When faced with complex tasks like debugging, analysis, or problem-solving, having AI break down problems into explicit, sequential steps dramatically improves accuracy. This is called chain-of-thought (CoT) prompting.

**Think of it like showing your work in math class**‚Äîby making the intermediate reasoning steps visible, you catch errors, verify logic, and produce more reliable results.

**Why This Works:**
- **Accuracy:** Breaking problems into steps reduces errors in complex tasks
- **Coherence:** Structured thinking leads to more organized responses
- **Debugging:** See the AI's thought process to identify where reasoning breaks down
- **Transparency:** Makes AI decision-making auditable and explainable

**When to Use CoT:**
- Complex debugging workflows
- Architectural decisions
- Security analysis
- Code review with multiple dimensions
- Multi-step troubleshooting

**How to Trigger CoT:**
1. **Simple:** Include "Think step-by-step" in your prompt
2. **Guided:** Outline specific steps for the AI to follow
3. **Structured:** Use XML tags like `<thinking>` and `<answer>` to separate reasoning from conclusions

**Important:** Always have the AI output its thinking. Without showing work, no systematic reasoning occurs!

---

### üìù Example 3: Root Cause Analysis (Force Analysis Before Diagnosis)

**Copy this to Circuit:**

```
You are a site reliability engineer skilled in root cause analysis.

Study this RCA methodology example:

EXAMPLE RCA:
Problem: API errors spiked from 1% to 15% at 2 PM. CPU normal, memory up 30%, disk I/O high.

Step 1: Correlate metrics with timeline
- Error spike: 2 PM
- Memory increase: Started 1:55 PM
- Disk I/O spike: Started 2 PM
- CPU usage: Normal throughout

Step 2: Identify primary symptom
- Main issue: API errors (functional impact)
- Secondary: Resource usage changes (memory, disk I/O)

Step 3: Find root cause
- Disk I/O correlates exactly with error spike (both at 2 PM)
- Memory leak started earlier (1:55 PM), likely caused disk swapping
- CPU normal rules out compute bottleneck
- Causal chain: Memory leak ‚Üí disk swapping ‚Üí API timeouts

Conclusion / Root cause:
Memory leak triggered disk swapping at 2 PM, causing API request timeouts and error spike.

---

Now apply the SAME 3-step format to diagnose this new incident:

A web service's response time spiked from 200ms to 2000ms at 3 PM.
CPU usage is normal, memory usage increased by 20%, and database query count doubled.

Use this exact structure:

Step 1: Correlate metrics with timeline
[List each metric with its timing]

Step 2: Identify primary symptom
[Distinguish main issue from secondary symptoms]

Step 3: Find root cause
[Analyze correlations, rule out non-factors, identify causal chain]

Conclusion / Root cause:
[Provide final diagnosis in one clear sentence]

Important: Follow the example's format exactly. Work through all steps before concluding.
```

**‚úÖ Self-Check: Your response should:**
- [ ] Follow all 3 steps in order (no skipping)
- [ ] Correlate timing of all metrics first
- [ ] Identify the primary symptom (response time increase)
- [ ] Trace the causal chain (what caused what)
- [ ] Provide a clear, evidence-based conclusion

**üí° Key Insight:** Notice how forcing step-by-step analysis prevents jumping to conclusions!

---

### üìù Example 4: Code Review with XML-Structured CoT

**Copy this to Circuit:**

```
You are a senior engineer debugging production issues. Use systematic step-by-step analysis.

Structure your response using XML tags:

<thinking>
Step 1: Analyze the symptoms and reproduce the issue
Step 2: Examine relevant logs and stack traces
Step 3: Identify potential root causes
Step 4: Trace the execution flow to pinpoint the problem
</thinking>

<analysis>
Provide detailed findings for each step, explaining what you discovered and why it matters
</analysis>

<solution>
Recommend specific fixes with code changes and verification steps
</solution>

Debug this production issue:

**Symptoms:**
- User reports: "Items randomly disappear from shopping cart"
- Happens intermittently, ~10% of users affected
- No errors in application logs
- Issue started after deploying new caching layer

**Code:**
```python
# Cart service with Redis cache
class CartService:
    def add_item(self, user_id, item_id, quantity):
        cart = redis.get(f'cart:{user_id}') or []
        cart.append({'item': item_id, 'qty': quantity})
        redis.set(f'cart:{user_id}', cart, ex=3600)  # 1 hour TTL
        return cart

    def get_cart(self, user_id):
        return redis.get(f'cart:{user_id}') or []

    def remove_item(self, user_id, item_id):
        cart = redis.get(f'cart:{user_id}') or []
        cart = [item for item in cart if item['item'] != item_id]
        redis.set(f'cart:{user_id}', cart, ex=3600)
        return cart
```

**Environment:**
- 5 application servers behind load balancer
- Single Redis instance (no clustering)
- Average request rate: 500 req/sec
```

**‚úÖ Self-Check: Your response should:**
- [ ] Include all XML sections (<thinking>, <analysis>, <solution>)
- [ ] Work through each step methodically in <thinking>
- [ ] Identify the race condition issue (multiple servers accessing Redis simultaneously)
- [ ] Explain the root cause clearly in <analysis>
- [ ] Provide concrete code fixes in <solution>

---

## üéØ Activity 2.2: Try It Yourself - Chain-of-Thought

**Scenario:** Code review with multiple potential issues (security, performance, quality).

### Step 1: Without CoT (Instant Analysis)

**Copy this to Circuit:**

```
Review this code:

```python
from flask import Flask, request, jsonify
import sqlite3

app = Flask(__name__)

@app.route('/user/<user_id>')
def get_user(user_id):
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    cursor.execute(f"SELECT * FROM users WHERE id = {user_id}")
    user = cursor.fetchone()
    conn.close()

    if user:
        return jsonify({
            "id": user[0],
            "name": user[1],
            "email": user[2]
        })
    else:
        return jsonify({"error": "User not found"}), 404
```

Context: This is a user lookup endpoint for a web application that handles 1000+ requests per minute during peak hours.
```

**Note what issues the AI finds...**

---

### Step 2: With Chain-of-Thought (Systematic Analysis)

**Now copy this to Circuit (new chat recommended):**

```
You are a senior software engineer conducting a comprehensive code review.

Analyze the code systematically using XML tags:

<security>
Identify security vulnerabilities with severity levels
</security>

<performance>
Analyze efficiency and optimization opportunities
</performance>

<quality>
Evaluate readability, maintainability, and best practices
</quality>

<recommendations>
Provide specific, prioritized fixes with code examples
</recommendations>

Review this code:

<code>
from flask import Flask, request, jsonify
import sqlite3

app = Flask(__name__)

@app.route('/user/<user_id>')
def get_user(user_id):
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    cursor.execute(f"SELECT * FROM users WHERE id = {user_id}")
    user = cursor.fetchone()
    conn.close()

    if user:
        return jsonify({
            "id": user[0],
            "name": user[1],
            "email": user[2]
        })
    else:
        return jsonify({"error": "User not found"}), 404
</code>

<context>
This is a user lookup endpoint for a web application that handles 1000+ requests per minute during peak hours.
</context>

Perform a comprehensive code review using the structured XML format.
```

### üìä Self-Evaluation Checklist

Compare both responses. The CoT version should:
- [ ] Identify SQL injection vulnerability (CRITICAL)
- [ ] Mention connection pooling issues for high traffic
- [ ] Note error handling gaps
- [ ] Provide code examples for fixes
- [ ] Organize findings by category (security, performance, quality)

**Score yourself:**
- **5/5 checks** = Excellent! CoT caught all issues systematically ‚úÖ
- **3-4/5 checks** = Good, systematic approach helps
- **0-2/5 checks** = Try being more explicit about the analysis steps

---

## üìñ Tactic 5: Reference Citations

**Ground responses in actual documentation to reduce hallucinations**

When working with long documents or multiple reference materials, asking AI to quote relevant parts first before completing tasks helps them focus on pertinent information and reduces hallucination.

**Why This Works:**
- AI identifies and focuses on relevant information before generating responses
- Citations make outputs verifiable and trustworthy
- Reduces hallucination by grounding responses in actual source material
- Easy to trace conclusions back to specific documentation sections

**Best Practices:**
- **Put documents at the top:** Place long documentation (~20K+ tokens) near the top of your prompt
- **Structure with XML tags:** Use `<documents>`, `<document>`, `<source>`, and `<document_content>` tags
- **Request quotes first:** Ask the AI to extract relevant quotes in `<quotes>` tags before generating the final response

---

### üìù Example 5: Multi-File Code Review with Citations

**Copy this to Circuit:**

```
You are a senior security engineer reviewing code for vulnerabilities.

<documents>
<document index="1">
<source>auth_service.py</source>
<document_content>
class AuthService:
    def __init__(self, db_connection):
        self.db = db_connection

    def authenticate_user(self, username, password):
        # TODO: Add password hashing
        query = f"SELECT * FROM users WHERE username='{username}' AND password='{password}'"
        result = self.db.execute(query)
        return result.fetchone() is not None

    def create_session(self, user_id):
        session_id = str(uuid.uuid4())
        # Session expires in 24 hours
        expiry = datetime.now() + timedelta(hours=24)
        self.db.execute(f"INSERT INTO sessions VALUES ('{session_id}', {user_id}, '{expiry}')")
        return session_id
</document_content>
</document>

<document index="2">
<source>user_controller.py</source>
<document_content>
from flask import Flask, request, jsonify
from auth_service import AuthService

app = Flask(__name__)
auth = AuthService(db_connection)

@app.route('/login', methods=['POST'])
def login():
    username = request.json.get('username')
    password = request.json.get('password')

    if auth.authenticate_user(username, password):
        user_id = get_user_id(username)
        session_id = auth.create_session(user_id)
        return jsonify({'session_id': session_id, 'status': 'success'})
    else:
        return jsonify({'status': 'failed'}), 401
</document_content>
</document>
</documents>

Review the authentication code above for security vulnerabilities.

First, extract relevant code quotes that demonstrate security issues and place them in <quotes> tags with the source file indicated.

Then, provide your security analysis in <analysis> tags, explaining each vulnerability and its severity.

Finally, provide specific remediation recommendations in <recommendations> tags.
```

**‚úÖ Self-Check: Your response should:**
- [ ] Quote specific vulnerable code lines in <quotes> tags
- [ ] Reference source files (auth_service.py, user_controller.py)
- [ ] Identify SQL injection vulnerabilities
- [ ] Mention plaintext password storage
- [ ] Provide concrete fixes in <recommendations>

**üí° Key Insight:** By requesting quotes first, the AI focuses on actual code problems instead of inventing generic security advice!

---

### üìù Example 6: API Documentation Analysis with Citations

**Copy this to Circuit:**

```
You are a technical integration specialist helping developers implement APIs.

<documents>
<document index="1">
<source>payment_api_docs.md</source>
<document_content>
# Payment API Documentation

## Authentication
All API requests require an API key passed in the `X-API-Key` header.
Rate limit: 1000 requests per hour per API key.

## Create Payment
POST /api/v2/payments

Creates a new payment transaction.

**Request Body:**
- amount (required, decimal): Payment amount in USD
- currency (optional, string): Currency code, defaults to "USD"
- customer_id (required, string): Customer identifier
- payment_method (required, string): One of: "card", "bank", "wallet"
- metadata (optional, object): Additional key-value pairs

**Rate Limit:** 100 requests per minute

**Response:**
{
  "payment_id": "pay_abc123",
  "status": "pending",
  "amount": 99.99,
  "created_at": "2024-01-15T10:30:00Z"
}

## Retrieve Payment
GET /api/v2/payments/{payment_id}

Retrieves details of a specific payment.

**Security Note:** Only returns payments belonging to the authenticated API key's account.

**Response Codes:**
- 200: Success
- 404: Payment not found
- 401: Invalid API key
</document_content>
</document>
</documents>

<integration_requirements>
I need to integrate payment processing into my e-commerce checkout flow.
The checkout needs to:
1. Create a payment when user clicks "Pay Now"
2. Handle USD and EUR currencies
3. Store order metadata with the payment
4. Check payment status after creation

What do I need to know from the API documentation?
</integration_requirements>

First, find and quote the relevant sections from the API documentation that address the integration requirements. Place these quotes in <quotes> tags with the section name indicated.

Then, provide a step-by-step integration guide in <integration_guide> tags that references the quoted documentation.
```

**‚úÖ Self-Check: Your response should:**
- [ ] Quote specific API documentation sections in <quotes>
- [ ] Reference section names (Authentication, Create Payment, etc.)
- [ ] Include required fields (amount, customer_id, payment_method)
- [ ] Mention the X-API-Key header requirement
- [ ] Provide implementation steps that match the documentation

---

## üéØ Activity 2.3: Try It Yourself - Reference Citations

**Scenario:** Implement Stripe payment API integration. Without documentation, AI will hallucinate API details.

### Step 1: Without Documentation (Hallucination Risk)

**Copy this to Circuit:**

```
Create a Python function to process Stripe payments.

The function should:
- Accept payment details like amount, card info, customer details
- Handle authentication with Stripe API
- Return the payment status

Make it production-ready with proper error handling.
```

**Watch for invented field names, wrong authentication methods, or incorrect API endpoints!**

---

### Step 2: With Reference Documentation (Grounded Response)

First, create these two documentation files locally or use them directly in the prompt:

**Now copy this to Circuit (new chat recommended):**

```
<documents>
  <document index="1">
    <source>docs/stripe-api-guide.md</source>
    <document_content>
# Stripe Payment Intents API

## Endpoint
POST https://api.stripe.com/v1/payment_intents

## Required Parameters
- amount (integer): Amount in cents (e.g., 1000 = $10.00)
- currency (string): Three-letter ISO currency code (e.g., "usd")
- payment_method_types (array): Payment methods to use (e.g., ["card"])

## Optional Parameters
- customer (string): Customer ID
- description (string): Payment description
- metadata (object): Key-value pairs for additional information

## Response
Returns a PaymentIntent object with status:
- requires_payment_method
- requires_confirmation
- requires_action
- processing
- succeeded
- canceled
    </document_content>
  </document>

  <document index="2">
    <source>docs/stripe-authentication.md</source>
    <document_content>
# Stripe Authentication

## API Key Authentication
All API requests must include your secret API key in the Authorization header:

```
Authorization: Bearer sk_test_YOUR_SECRET_KEY
```

## Key Types
- **Secret key** (sk_): Server-side only, never expose in client code
- **Publishable key** (pk_): Client-side safe

## Security Best Practices
- Store secret keys in environment variables
- Never commit keys to version control
- Use test keys (sk_test_) in development
- Rotate keys if compromised
    </document_content>
  </document>
</documents>

Task: Create a Python function to process Stripe payments.

The function should:
- Accept payment details like amount, card info, customer details
- Handle authentication with Stripe API
- Return the payment status

Make it production-ready with proper error handling.

Step 1: Extract relevant quotes from the documentation above.
In <quotes> tags, extract:
- Required API fields from document 1
- Authentication format from document 2
- Correct endpoint from document 1

Step 2: Using ONLY the quoted information, provide implementation in <code> tags.
```

### üìä Self-Evaluation Checklist

Compare both responses. The documented version should:
- [ ] Use correct endpoint (https://api.stripe.com/v1/payment_intents)
- [ ] Include required fields (amount, currency, payment_method_types)
- [ ] Use Bearer token authentication (not invented methods)
- [ ] Convert dollars to cents (amount in cents)
- [ ] Use proper field names from documentation

**Score yourself:**
- **5/5 checks** = Excellent! Citations prevented hallucination ‚úÖ
- **3-4/5 checks** = Good, but review the quoted documentation more carefully
- **0-2/5 checks** = The AI may not have extracted quotes first‚Äîtry being more explicit

---

## üéñÔ∏è Skill Tracker

After completing the activities above, check off the skills you've mastered:

### Few-Shot Examples Skills
- [ ] **Skill #1:** I can create 2-5 examples to teach AI my preferred formats
- [ ] **Skill #2:** I can use examples to enforce consistent categorization
- [ ] **Skill #3:** I can apply few-shot patterns to log parsing and alert categorization

### Chain-of-Thought Skills
- [ ] **Skill #4:** I can force systematic analysis before conclusions (RCA pattern)
- [ ] **Skill #5:** I can use XML tags (<thinking>, <analysis>, <solution>) to structure reasoning
- [ ] **Skill #6:** I can apply CoT to debugging and code review workflows

### Reference Citations Skills
- [ ] **Skill #7:** I can structure multi-document prompts with proper XML tags
- [ ] **Skill #8:** I can request quote extraction before analysis to reduce hallucinations
- [ ] **Skill #9:** I can reference external documentation to ground API implementations

**üèÜ Mastery Level:**
- **9/9 skills** = Expert! Ready for advanced workflows ‚úÖ
- **6-8/9 skills** = Proficient! Practice the missing skills
- **3-5/9 skills** = Good start! Revisit examples above
- **0-2/9 skills** = Keep practicing! Try each example again

---

## üí° Key Takeaways

### When to Use Few-Shot Examples
‚úÖ Enforcing specific output formats (logs, error messages, commit messages)
‚úÖ Teaching custom categorization schemes (your team's alert categories)
‚úÖ Consistent code documentation styles
‚úÖ Test case patterns (given-when-then, arrange-act-assert)

### When to Use Chain-of-Thought
‚úÖ Complex debugging scenarios
‚úÖ Security analysis with multiple dimensions
‚úÖ Root cause analysis (RCA)
‚úÖ Code review requiring systematic evaluation
‚úÖ Architectural decisions with trade-offs

### When to Use Reference Citations
‚úÖ API integration from documentation
‚úÖ Code review with large codebases
‚úÖ Multi-file refactoring
‚úÖ Security audits referencing compliance docs
‚úÖ Any task where hallucination must be minimized

### Best Practices Learned
1. **Few-shot:** 2-5 examples is the sweet spot (more isn't always better)
2. **CoT:** Always request that the AI output its thinking steps
3. **Citations:** Put long documents at the top, request quotes first
4. **Combine tactics:** Use role prompting + few-shot + CoT for powerful results
5. **XML tags:** Consistent structure makes it easy to parse and verify outputs

---

## ‚è≠Ô∏è Next Steps

<div style="background:rgb(12, 88, 160); padding: 16px; border-radius: 8px; border-left: 4px solid #3b82f6;">

**Continue to Section 2.4: Advanced Workflows**

Learn how to use:
- üîó **Prompt chaining** to break complex tasks into sequential workflows
- üå≥ **Tree of thoughts** to explore multiple solution approaches
- ‚öñÔ∏è **LLM-as-judge** to create evaluation rubrics and self-correction loops

[View 2.4-advanced-workflows.md](./2.4-advanced-workflows.md) ‚Üí

</div>

---

## ü§î Troubleshooting

**Q: My few-shot examples aren't working**
**A:** Try these fixes:
1. Use 3-5 examples (2 might not be enough for complex patterns)
2. Make examples diverse (cover different scenarios)
3. Be consistent in format across all examples
4. Add a note: "Follow this EXACT format"

**Q: Chain-of-thought isn't triggering**
**A:** Make sure:
1. You explicitly request step-by-step reasoning
2. You use XML tags like <thinking> to structure it
3. You don't skip directly to asking for the answer

**Q: AI still hallucinates despite documentation**
**A:** Strengthen your prompt:
1. Put documentation at the very top
2. Request quotes in <quotes> tags FIRST
3. Say "Using ONLY the quoted information..."
4. Use XML tags to structure the documents

---

## üìö Related Resources

- [Claude Documentation - Multishot Prompting](https://docs.claude.com/en/docs/build-with-claude/prompt-engineering/multishot-prompting)
- [Claude Documentation - Chain of Thought](https://docs.claude.com/en/docs/build-with-claude/prompt-engineering/chain-of-thought)
- [Claude Documentation - Long Context Tips](https://docs.claude.com/en/docs/build-with-claude/prompt-engineering/long-context-tips)
- [Full Interactive Notebook](./2.3-patterns-for-reasoning.ipynb) (requires API access)

---

**üìù Note:** This template guide is a companion to the full Jupyter notebook. If you have API access (GitHub Copilot, OpenAI, Claude), use the interactive notebook for automated evaluation and progress tracking.
